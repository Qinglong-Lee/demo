package com.example.study.rmi.jndiVulnerability;

import javax.naming.InitialContext;
import javax.naming.NamingException;

public class JNDILookup {
    public static void main(String[] args) {

        try {


//            默认不允许从远程的Codebase加载Reference工厂类，这里是放开限制
            System.setProperty("com.sun.jndi.rmi.object.trustURLCodebase", "true");
            System.setProperty("com.sun.jndi.ldap.object.trustURLCodebase", "true");
//            通过 JNDI 的标准接口远程调用过程中如果返回的是一个【带有工厂类地址的 Reference 对象】
//            则会先在本地通过工厂类全类名查找，没找到就去地址所指的远程服务器获取并反序列化
            Object ret = new InitialContext().lookup("rmi://localhost:10099/Foo");

            System.out.println("ret: " + ret);
        } catch (NamingException e) {
            e.printStackTrace();
        }
    }
}


